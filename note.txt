################################################################################
	BUILD COMMAND
################################################################################

make ARCH=arm64 defconfig
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j8 -sw
make ARCH=arm64 tags cscope

/home/freestyle/Workspace/other/qemu.git/aarch64-softmmu/qemu-system-aarch64 -machine virt -cpu cortex-a57 -machine type=virt -nographic -smp 4 -m 2048 -kernel arch/arm64/boot/Image --append "console=ttyAMA0"
ddd --gdb --debugger /opt/crosstools/gcc-linaro-5.3-2016.02-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gdb




################################################################################
	KERNEL MEMORY MAP
################################################################################

	1. VA에서 kernel address space가 주소 끝쪽으로 이동했다.
	2. 1:1 mapping 할 충분한 공간이 있이므로 high memory mapping이 없어졌다.

FILE: arch/arm64/include/asm/memory.h
/*
 * PAGE_OFFSET - the virtual address of the start of the linear map (top
 *		 (VA_BITS - 1))
 * KIMAGE_VADDR - the virtual address of the start of the kernel image
 * VA_BITS - the maximum number of bits for virtual addresses.
 * VA_START - the first kernel virtual address.
 * TASK_SIZE - the maximum size of a user space task.
 * TASK_UNMAPPED_BASE - the lower boundary of the mmap VM area.
 */

 KIMAGE_VADDR : the virtual base of the kernel region
 TEXT_OFFSET  : RANDOMIZE가 아니면 0x80000

 PAGE_OFFSET이 linear map 용도로 변경되었다. commit comment
arm64: split linear and kernel mappings
At the request of Catalin, this series has been split off from my series
'arm64: implement support for KASLR v4' [1]. This sub-series deals with
moving the kernel out of the linear mapping into the vmalloc area. This
is a prerequisite for independent physical and virtual randomization of
the kernel image. On top of that, considering that these changes allow
the linear mapping to start at an arbitrary offset above PAGE_OFFSET, it
should be an improvement in itself due to the fact that we can now choose
PAGE_OFFSET such that RAM can be mapped using large block sizes.


#define VA_BITS			(CONFIG_ARM64_VA_BITS)
	v4.6에서 4KB 3level 39bit, v4.7+에서 4KB 3level 48bit
#define VA_START		(UL(0xffffffffffffffff) << VA_BITS)
	>>> hex(0xffffffffffffffff << 39 & 0xffffffffffffffff)
	'0xffffff8000000000'
#define PAGE_OFFSET		(UL(0xffffffffffffffff) << (VA_BITS - 1))
	>>> hex((0xffffffffffffffff << (39-1)) & 0xffffffffffffffff)
	'0xffffffc000000000'
#define KIMAGE_VADDR		(MODULES_END)
	0xffffff8008000000
#define MODULES_END		(MODULES_VADDR + MODULES_VSIZE)
	0xffffff8008000000 = 0xffffff8000000000 + 0x08000000
#define MODULES_VADDR		(VA_START + KASAN_SHADOW_SIZE)
	0xffffff8000000000
	

FILE: Documentation/arm64/memory.txt (v4.6)

AArch64 Linux memory layout with 4KB pages + 3 levels:

Start			End			Size		Use
-----------------------------------------------------------------------
0000000000000000	0000007fffffffff	 512GB		user
ffffff8000000000	ffffffffffffffff	 512GB		kernel

Translation table lookup with 4KB pages:

+--------+--------+--------+--------+--------+--------+--------+--------+
|63    56|55    48|47    40|39    32|31    24|23    16|15     8|7      0|
+--------+--------+--------+--------+--------+--------+--------+--------+
 |                 |         |         |         |         |
 |                 |         |         |         |         v
 |                 |         |         |         |   [11:0]  in-page offset
 |                 |         |         |         +-> [20:12] L3 index
 |                 |         |         +-----------> [29:21] L2 index
 |                 |         +---------------------> [38:30] L1 index
 |                 +-------------------------------> [47:39] L0 index
 +-------------------------------------------------> [63] TTBR0/1


FILE: Documentation/arm64/booting.txt

Requirement: MANDATORY

The decompressed kernel image contains a 64-byte header as follows:

  u32 code0;			/* Executable code */
  u32 code1;			/* Executable code */
  u64 text_offset;		/* Image load offset, little endian */
  u64 image_size;		/* Effective Image size, little endian */
  u64 flags;			/* kernel flags, little endian */		// endianness, page size, physical placement
  u64 res2	= 0;		/* reserved */
  u64 res3	= 0;		/* reserved */
  u64 res4	= 0;		/* reserved */
  u32 magic	= 0x644d5241;	/* Magic number, little endian, "ARM\x64" */
  u32 res5;			/* reserved (used for PE COFF offset) */




FILE: System.map

ffffff8008080000 A __efistub__text
ffffff8008080000 t _head
ffffff8008080000 T _text
...
ffffff8008c01000 A __efistub__end
ffffff8008c01000 B _end


















================================================================================
* 토픽 : SMP CORE 끼리 인터럽트는 어떻게 주고 받을까?
	- How do interrupts work on multicore ARM cpu
	- Send Inter-Processor Interrupts in Zynq

* 환경
qemu cortex-a57 quad, kernel 4.6,

# dmesg | grep -i gic
[    0.000000] GICv2m: range[mem 0x08020000-0x08020fff], SPI[80:143]


* IPI에는 어떤 것들이 있나? 대표적인 호출 예제
	S(IPI_RESCHEDULE, "Rescheduling interrupts"),
	S(IPI_CALL_FUNC, "Function call interrupts"),
	S(IPI_CPU_STOP, "CPU stop interrupts"),
	S(IPI_TIMER, "Timer broadcast interrupts"),
	S(IPI_IRQ_WORK, "IRQ work interrupts"),
	S(IPI_WAKEUP, "CPU wake-up interrupts"),

* 호출 flow
	=> 아래 정리

* 호출 API
	smp_cross_call(mask, IPI_CALL_FUNC);



// arch/arm64/kernel/entry.S

ENTRY(vectors)
	ventry	el1_sync_invalid		// Synchronous EL1t
	ventry	el1_irq_invalid			// IRQ EL1t
	ventry	el1_fiq_invalid			// FIQ EL1t
	ventry	el1_error_invalid		// Error EL1t

	ventry	el1_sync			// Synchronous EL1h
	ventry	el1_irq				// IRQ EL1h		// el1_irq
	ventry	el1_fiq_invalid			// FIQ EL1h
	ventry	el1_error_invalid		// Error EL1h

	...

el1_irq:
	kernel_entry 1
	enable_dbg

	get_thread_info tsk
	irq_handler						// irq_handler

/*
 * Interrupt handling.
 */
	.macro	irq_handler
	ldr_l	x1, handle_arch_irq				// handle_arch_irq
	mov	x0, sp
	irq_stack_entry
	blr	x1
	irq_stack_exit
	.endm


gic_of_init
	__gic_init_bases
		set_handle_irq(gic_handle_irq);			// handle_arch_irq 지정

gic_handle_irq							// drivers/irqchip/irq-gic.c
	irqnr = irqstat & GICC_IAR_INT_ID_MASK;
	if (irqnr < 16) {
#ifdef CONFIG_SMP
		handle_IPI(irqnr, regs);			// arch/arm64/kernel/smp.c
#endif


void handle_IPI(int ipinr, struct pt_regs *regs)
{
	unsigned int cpu = smp_processor_id();
	struct pt_regs *old_regs = set_irq_regs(regs);

	if ((unsigned)ipinr < NR_IPI) {
		trace_ipi_entry_rcuidle(ipi_types[ipinr]);
		__inc_irq_stat(cpu, ipi_irqs[ipinr]);
	}

	switch (ipinr) {
	case IPI_RESCHEDULE:
		scheduler_ipi();
		break;

	case IPI_CALL_FUNC:
		irq_enter();
		generic_smp_call_function_interrupt();
		irq_exit();
		break;

	case IPI_CPU_STOP:
		irq_enter();
		ipi_cpu_stop(cpu);
		irq_exit();
		break;

#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
	case IPI_TIMER:
		irq_enter();
		tick_receive_broadcast();
		irq_exit();
		break;
#endif

#ifdef CONFIG_IRQ_WORK
	case IPI_IRQ_WORK:
		irq_enter();
		irq_work_run();
		irq_exit();
		break;
#endif

#ifdef CONFIG_ARM64_ACPI_PARKING_PROTOCOL
	case IPI_WAKEUP:
		WARN_ONCE(!acpi_parking_protocol_valid(cpu),
			  "CPU%u: Wake-up IPI outside the ACPI parking protocol\n",
			  cpu);
		break;
#endif

	default:
		pr_crit("CPU%u: Unknown IPI message 0x%x\n", cpu, ipinr);
		break;
	}

	if ((unsigned)ipinr < NR_IPI)
		trace_ipi_exit_rcuidle(ipi_types[ipinr]);
	set_irq_regs(old_regs);
}




# cat /proc/interrupts 
           CPU0       CPU1       CPU2       CPU3       
  3:        601        658        577        621     GIC-0  27 Edge      arch_timer
 38:          0          0          0          0     GIC-0  34 Level     rtc-pl031
 39:         91          0          0          0     GIC-0  33 Level     uart-pl011
 43:          0          0          0          0     pl061   3 Edge      GPIO Key Poweroff
 49:          0          0          0          0       MSI 16384 Edge      virtio0-config
 50:          0          0          0          0       MSI 16385 Edge      virtio0-input.0
 51:          0          0          0          0       MSI 16386 Edge      virtio0-output.0
IPI0:       224        212        212        268       Rescheduling interrupts
IPI1:         5          2          3          4       Function call interrupts
IPI2:         0          0          0          0       CPU stop interrupts
IPI3:         0          0          0          0       Timer broadcast interrupts
IPI4:         0          0          0          0       IRQ work interrupts
IPI5:         0          0          0          0       CPU wake-up interrupts
Err:          0
# 
